# *Практическое занятие №1*
# UPD: Файл обновлен, см. дополнение после списка литературы.

## **Знакомство со средой моделирования Wokwi. Интерфейс симулятора, основы работы**
____________________

## **Цель работы**

> Целью практического занятия является получение практических навыков работы со средой моделирования и разработки микроконтроллерных модулей цифровых платформ.

_____________________

## **Теоретическая часть**

> На сегодняшний день про платформу Arduino слышали многие. Arduino --- это самая динамично развивающаяся и доступная платформа с низким порогом вхождения, которая доступна как для начинающих и делающих первые шаги в программировании, так и для профессионалов.

### **Возможности**

Платформа Arduino представляет собой комбинацию среды быстрой разработки
Arduino IDE и модулей для прототипирования на базе микроконтроллеров.
Фактически, Arduino это простейший электронный конструктор для
создания готовых устройств из отдельных модулей. Arduino пользуется
огромной популярностью во всем мире из-за контроллеров, модулей и шилдов
(Шилд для Arduino - это разновидность плат расширения, которые состыкуется с
Arduino. Расширяющие функционал шилды, так же, как и
Arduino модули, имеют на своем борту конкретный элемент (драйвер
двигателей, Ethernet контроллер, дисплей и т.п.) со всей необходимой схемотехнической
обвязкой для его работы. В отличии от модулей, которые можно подключить
к произвольным пинам Arduino, выводы шилда, в большинстве случаев,
жестко привязаны к выводам Arduino).

Arduino не просто универсальный микроконтроллер (если быть точнее, плата разработки с микроконтроллером), который можно
адаптировать под любой проект за минимальное время. Это еще и среда разработки Arduino IDE, которая служит для
вовлечения в программирование и робототехнику, а также для быстрой
разработки проектов. На основе Arduino можно собрать различные устройства, а также запрограммировать им собственную логику работы, например алгоритмы измерения. Все это происходит благодаря тому, что у платформы Arduino
одно из самых больших сообществ, а также доступно огромное количество
примеров, руководств и готовых библиотек для разработки.

### **Модули Arduino**

Модули базовых контроллеров Arduino получили широкое распространение
благодаря своей универсальности. Популярные платы Arduino Uno и Leonardo
имеют стандартный набор периферии (его мы рассмотрим на следующих занятиях), а платы Mega и Due - расширенный.
Даже компактные модули типа Pro, Micro и Nano подойдут для собственного
проекта. В последнее время появились модули Mega сразу с установленным
SoC ESP8266 и беспроводной связью Wi-Fi на борту.

Модули Arduino представляют собой платы со встроенным микроконтроллером или процессором,
памятью и периферией, которая позволяет реализовать базовый функционал
посредством одной всего платы. Для расширения возможностей служат
дополнительные модули-шилды, которые работают с двигателями и сенсорами
различных типов, а также способны читать и писать на карты памяти и
накопители, поддерживают USB Host, умеют работать с Ethernet, Bluetooth
и Wi-Fi. Модули расширения уровня Industrial имеют гальваническую
развязку, а модули для умного дома подойдут с целью прототипирования
устройств IoT («интернета вещей»). Некоторые модули достаточно производительны, на них можно реализовать собственный Web-сервер.

На сегодняшний день существует множество оригинальных разновидностей и
популярных клонов, а также огромное количество совместимых
модулей-шилдов. Для прототипирования и обучения доступен огромный
арсенал периферии. Это разнообразные сенсоры, большинство типов датчиков
и исполнительных механизмов, различные дисплеи, буферные и усилительные
модули, драйверы двигателей, модули для беспроводной связи и управления.
Модули комбинируются с основной платой-контроллером и затем
конфигурируются в среде Arduino IDE. Следовательно, такие устройства являются идеальными кандидатами для разработки оконечных устройств сенсорной или цифровой платформы.

Таким образом, устройства, созданные на платформе Arduino можно
использовать для сбора информации об окружающей среде в автономном
режиме, оставляя эту работу группе микроконтроллеров

Отметим, что сама по себе плата разработки не представляет интереса в области цифровых платформ, она рассматривается исключительно как база для какого-либо устройства.
Для начала установим, что под устройством (или его прототипом), будем понимать совокупность аппаратной платформы (платы Arduino), алгоритмической составляющей и программного кода.
При этом алгоритм должен описывать как минимум две части работы устройства - его начальную настройку и основной цикл работы.
Программная часть также повторяет этот принцип. Следовательно, в программе должны присутствовать как минимум две функции: Setup() и Loop().
Обе эти функции по умолчанию имеют тип Void, то есть не возвращают никаких значений. При подаче электропитания на плату разработки первой вызывается функция Setup(), в ней описываются инициализация соединений, сокетов, драйверов и прочих вспомогательных решений.
При условии корректного выполнения начальной настроки вызывается функция Loop(), что в дословном переводе означает "цикл". То есть, эта функция будет выполняться до возникновения ошибки или отключения питания устройства.
Обе эти функции являются "прошивкой" устройства и хранятся в энергонезависимой памяти контроллера, а результаты вычисления наоборот, удаляются при отключении питания.
Помимо этого, возможно использование заголовков, в которых можно глобально задать какие-либо параметры или подключить внешние библиотеки. Пример: `#define LED_BUILTIN 27`, объявленный в начале программы четко определит значение переменной `LED_BUILTIN`.
Далее разберем одну из реализаций симулятора плат разработки Arduino. 

### **Wokwi**
Это онлайн симулятор электронных схем, который
позволяет моделировать ваши микроконтроллерные проекты. Wokwi работает в
браузере, поэтому устанавливать на компьютер ничего не понадобится. Не
потребуется даже никаких аппаратных компонентов.

Данный симулятор позволяет провести моделирование планируемого
устройства, не покупая компонентов и деталей, что позволяет опробировать какие-либо алгоритмы не потратив времени на настройку аппаратной составляющей проекта.

Wokwi имитирует работу популярных плат для прототипирования и обучения
работе с микроконтроллерами, таких как Arduino, ESP32 DevKit, Raspberry
Pi Pico и ряд другиx. Для создания виртуальных электронных схем в
симуляторе присутствуют светодиоды, кнопки, датчики, сервомотор,
динамик, дисплеи, microSD-карта.

Такой набор позволяет не только обучиться основам программирования оконечных устройств цифровых платформ, но и разработать прототип автоматизированного устройства измрения.


_____________________________

## **Практическая часть**

### ***Запуск виртуальной среды***

Как уже было сказано, для работы в среде ничего не нужно устанавливать,
даже регистрация необязательна. Достаточно зайти на сайт
<https://wokwi.com>.

На стартовой странице можно выбрать условия для создания нового проекта.
Создадим новый проект, чтобы поисследовать возможности симулятора. Для
создания доступны платформы Arduino, ESP32, STM32, Pi Pico, но на данном
практическом занятии достаточно использовать лишь одну из них --
подойдёт ESP32. В «Starter Templates» нужно выбрать базовый вариант --
просто ESP32

![](./media/image1.png)

Рисунок 1 - Стартовая страница среды

### ***Интерфейс симулятора***

При создании нового проекта пользователь увидит следующую картинку.

![](./media/image2.png)

Рисунок 2 - Новый проект

Слева - текстовый редактор, где можно работать с файлами программы (и
не только), а справа - непосредственно поле симулятора. Сейчас там
только базовая плата. Для того что бы добавить какой-либо элемент
необходимо нажать на кнопку «+» и откроется выпадающий список элементов.

Попробуем создать самый простой пример - всё необходимое для
стандартного примера Blink - светодиод и резистор. Добавим их на
экран, и соединим. Для того, чтобы соединить пины - штыревые разъёмы, и
контакты элементов необходимо просто нажать на один контакт, а затем на
другой.

Светодиоды используются для индикации различных событий в целях
определения статуса работы устройства для корректности его работы. На
этапе начальной разработки любого устройства рекомендуется использовать
больше индикаторов состояний, чем требуется для работы. Так будет
удобнее делать отладку программы.

![https://habrastorage.org/r/w1560/getpro/habr/upload_files/0af/f3b/721/0aff3b721eef56fb94fb1fe1f25ec7ee.png](./media/image3.png)

Рисунок 3 - Подключение новых элементов

После добавления элемента на поле, если навести на него указатель,
появляется рамочка с вопросительным знаком. Нажав на вопросительный знак можно попасть на страницу документации того или иного элемента.

Теперь в левой части окна добавим стандартный пример Blink, не забыв
указать нужный нам пин. Для этого зайдём в документацию светодиода, в
конце страницы есть ссылка на примеры симулятора, в данном случае нужен
«Blink - Arduino\'s standard Blink sketch». Достаточно будет взять код
из открывшегося примера и с помощью #define уточнить, какой вход
используется.

```
#define LED_BUILTIN 27
// the setup function runs once when you press reset or power the board

void setup() {
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
}

// the loop function runs over and over again forever
void loop() {
  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)
  delay(1000);                       // wait for a second
  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW
  delay(1000);                       // wait for a second
}
```
Запустим симуляцию, нажав на зелёную кнопку «Run».

![https://habrastorage.org/getpro/habr/upload_files/36d/584/9c3/36d5849c370f3b4b3024b9a47c2d40a5.gif](./media/image4.gif)
Рисунок 4 -- Выполнение программы диода

Помимо листа для основной программы «sketch.ino» есть также лист
«diagram.json», предназначенный для того, чтобы можно было менять
настройки элементов. Вот как он выглядит для проекта данного
практического занятия:

```
{
  \"version\": 1,
  \"author\": \"username\",
  \"editor\": \"wokwi\",
  \"parts\": \[

    { \"type\": \"wokwi-esp32-devkit-v1\", \"id\": \"esp\", \"top\": 0,
\"left\": 0, \"attrs\": {} },

    {
      \"type\": \"wokwi-led\",
      \"id\": \"led1\",
      \"top\": -19.33,
      \"left\": -223.8,
      \"attrs\": { \"color\": \"red\" }
    },

    {
      \"type\": \"wokwi-resistor\",
      \"id\": \"r1\",
      \"top\": 147.56,
      \"left\": -174.01,
      \"attrs\": { \"value\": \"1000\" }
    }

  \],

  \"connections\": \[
    \[ \"esp:TX0\", \"\$serialMonitor:RX\", \"\", \[\] \],
    \[ \"esp:RX0\", \"\$serialMonitor:TX\", \"\", \[\] \],
    \[ \"esp:GND.2\", \"r1:2\", \"black\", \[ \"h0\" \] \],
    \[ \"led1:C\", \"r1:1\", \"green\", \[ \"v0\" \] \],
    \[ \"esp:D27\", \"led1:A\", \"green\", \[ \"h0\" \] \]
  \],

  \"dependencies\": {}
}
```

Чаще всего, редактировать придётся объекты, содержащиеся в блоке parts - это описание элементов и в блоке connections - это описание проводов соединений.

Какие атрибуты можно менять у светодиода и резистора? Об этом можно почитать в документации. Вызов документации происходит после нажатия знака "?", при наведении на отдельный элемент, помещенный на поле симулятора.
Пока заменим у светодиода явно заметный параметр - цвет (Также вызывается при нажатии на добавленный диод).

Кроме этого изменим цвет проводов на соответствующий общепринятым: те,
что идут к земле сделаем чёрными, а те, что к питанию (в нашем случае, к
пину 27), красными.

И тогда файл проекта будет таким:
```
{
  \"version\": 1,
  \"author\": \"username\",
  \"editor\": \"wokwi\",
  \"parts\": \[

    { \"type\": \"wokwi-esp32-devkit-v1\", \"id\": \"esp\", \"top\": 0,
\"left\": 0, \"attrs\": {} },

    {
      \"type\": \"wokwi-led\",
      \"id\": \"led1\",
      \"top\": -19.33,
      \"left\": -223.8,
      \"attrs\": { \"color\": \"blue\" }
    },

    {
      \"type\": \"wokwi-resistor\",
      \"id\": \"r1\",
      \"top\": 147.56,
      \"left\": -174.01,
      \"attrs\": { \"value\": \"1000\" }
    }

  \],

  \"connections\": \[
    \[ \"esp:TX0\", \"\$serialMonitor:RX\", \"\", \[\] \],
    \[ \"esp:RX0\", \"\$serialMonitor:TX\", \"\", \[\] \],
    \[ \"led1:C\", \"r1:1\", \"black\", \[ \"v0\" \] \],
    \[ \"r1:2\", \"esp:GND.2\", \"black\", \[ \"v0\" \] \],
    \[ \"led1:A\", \"esp:D27\", \"red\", \[ \"v0\" \] \]
  \],

  \"dependencies\": {}
}
```
А выглядеть будет так.

![https://habrastorage.org/r/w1560/getpro/habr/upload_files/afe/8b8/1e2/afe8b81e23da394823e0e8ef69b741bc.png](./media/image5.png)
Рисунок 5 - Стандартизированный вид подключения

Кроме атрибутов у всех объектов можно менять местоположение в
координатах. Это помогает сделать более наглядную модель, с которой удобно
работать.

Теперь сделаем ввод информации в контроллер. Пусть это будет кнопка. При
считывании кнопки значение HIGH соответствует нажатию, а LOW -- его
отсутствие. Требуется сначала добавить кнопку, подключить к ней провода:
1.l или 1.r к одному из входов основной платы, 2.l или 2.r к земле.
Также нужно сконфигурировать пин на контроллере как вход для приёма
данных. Осталось написать программу для выполнения по нажатию

```cpp
#define LED_BUILTIN 27
#define input 26

int program(){
  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)
  delay(1000);                       // wait for a second
  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW
  delay(1000);                       // wait for a second  
  return 0;
}

// Переменная для хранения состояния кнопки
int buttonState = 0;

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(input, INPUT); //конфигурация пина, относящегося к кнопке, на вход
}

void loop() {
  buttonState = digitalRead(input);
  if (buttonState == HIGH){
    program();
    }
}

```
![](./media/image6.png)

Рисунок 6 - Подключение кнопки


Соберите схему, аналогичную рисунку ниже. Вам потребуется ESP32, три светодиода и потенциометр (на рисунке тип Slide). Этот потенциометр при работе программы (после нажатия кнопки Run), можно передвигать, тем самым меняя его значение.
![](./media/upd3.jpg)

Теперь используйте программный код ниже, после его выполнения постарайтесь разобраться почему он работает именно так (коментарии в этом коде намеренно опущены).

```cpp
int led1 = 21; int led2 = 19; int led3 = 18; // светодиоды
int datapin = 34; // 34 пин потенциометра

int val = 0;
void setup() {     
  Serial.begin(9600);           
  pinMode(led1, OUTPUT);
  pinMode(led2, OUTPUT); 
  pinMode(led3, OUTPUT); 
}
void loop() {
  val = 0;
  if (analogRead (datapin) > 600){ val = 1;}
  if (analogRead (datapin) > 1000){ val = 2;}
  if (analogRead (datapin) > 2000){ val = 3;}
  Serial.println(analogRead (datapin));
  Serial.println(val);
  switch (val)
  {
  case 1: 
    digitalWrite(led1, HIGH);   break;
  case 2:
    digitalWrite(led2, HIGH);	break;
  case 3: 
    digitalWrite(led3, HIGH); break;
  default:
    digitalWrite(led1, LOW);
    digitalWrite(led2, LOW);
    digitalWrite(led3, LOW);
    break;
  }
}
```

### ***Библиотеки и модули***

Для пользователя доступны множество библиотек и функций, готовых к
работе. Это библиотеки для элементов доступных в симуляторе - таких
как NeoPixel или семисегментный индикатор. Для ESP32 доступна
возможность подключения к интернету и к MQTT брокеру.

На сайте <https://docs.wokwi.com/guides/esp32> можно увидеть больше
примеров и подробностей использования плат в рамках симулятора.

На сайте доступно много примеров по работе с библиотеками на примере
Arduino:

![https://habrastorage.org/r/w1560/getpro/habr/upload_files/a43/b75/e57/a43b75e571d0c4c2a3a15359986c674d.png](./media/image7.png)

Рисунок 7 -- Один из примеров применения доступных инструментов


## **Список рекомендуемой литературы**

1.  [Документация микроконтроллера ESP32 Wokwi](https://docs.wokwi.com/guides/esp32)

2.  [Рощупкин Э. В. Моделирование и отладка режимов работы информационно-измерительных систем экологического мониторинга на микроконтроллерах //Известия Тульского государственного университета. Технические науки. – 2010. – №. 2-2. – С. 147-152.](https://cyberleninka.ru/article/n/modelirovanie-i-otladka-rezhimov-raboty-informatsionno-izmeritelnyh-sistem-ekologicheskogo-monitoringa-na-mikrokontrollerah)

3.  [Цыбин В. В., Хрусталев В. И. Использование микроконтроллеров arduino для мониторинга качества воды //Новое слово в науке: перспективы развития. – 2016. – №. 4-1. – С. 10.](https://interactive-plus.ru/e-articles/292/Action292-116941.pdf)

4.  [Основы программирования Arduino микроконтроллеров](https://habr.com/ru/articles/352806/)


___________________________
___________________________
___________________________
# UPD

Рассмотрим подробнее интерфейс симулятора Arduino: в левой части находится программный код (вкладка sketch.ino), описание собранной схемы на языке разметки (diagram.json), и список подключенных библиотек (Library Manager), а в правой - интерфейс добавления различных модулей, соединения их с основной платой и графическое отображение получившейся схемы.

![](./media/upd1.jpg)

В первой вкладке находится непосредственно программный код разрабатываемого устройства. Он описывает алгоритм работы устройства, его отдельные функции, то как устройство будет считывать, обрабатывать или передавать данные с подключаемых датчиков. С этим полем связана основная работа разработчика. При этом программый код должен соответствовать требованиям Arduino, в противном случае можно получить вместо рабочего устройства ряд ошибок, которые укажут строку некорректного кода.

Во второй вкладке описана схема, но не в графическом виде, а в виде языка разметки JSON. Такое описание занимает меньший объем памяти, чем графика, и, иногда, его проще редактировать. Разберемся подробнее в обозначениях этого языка разметки.
В примере с кнопкой имеем следующее описание схемы:


```json
{
  "version": 1,
  "author": "user",
  "editor": "wokwi",
  "parts": [
    { "type": "wokwi-esp32-devkit-v1", "id": "esp", "top": 0, "left": 0, "attrs": {} },
    {
      "type": "wokwi-led",
      "id": "led1",
      "top": -19.33,
      "left": -223.8,
      "attrs": { "color": "blue" }
    },
    {
      "type": "wokwi-resistor",
      "id": "r1",
      "top": 147.56,
      "left": -174.01,
      "attrs": { "value": "1000" }
    },
    {
      "type": "wokwi-pushbutton",
      "id": "btn1",
      "top": 184.87,
      "left": -104.93,
      "attrs": { "color": "green", "bounce": "1" }
    }
  ],
  "connections": [
    [ "esp:TX0", "$serialMonitor:RX", "", [] ],
    [ "esp:RX0", "$serialMonitor:TX", "", [] ],
    [ "led1:C", "r1:1", "black", [ "v0" ] ],
    [ "r1:2", "esp:GND.2", "black", [ "v0" ] ],
    [ "led1:A", "esp:D27", "red", [ "v0" ] ],
    [ "btn1:1.r", "esp:D26", "green", [ "v0" ] ],
    [ "btn1:2.r", "esp:GND.2", "black", [ "h0" ] ]
  ],
  "dependencies": {}
}

```

Сразу обратим внимание, что структура этого кода иерархична и представляет собой дерево. Каждая ветвь этого дерева отделена запятой, а подветвь заключена в квадратные скобки.
Таким образом, структуру этого JSON файла можно представить в следующем виде:

```
---|
   |---version
   |---author
   |---editor
   |---parts
       |---[]
   |---connections
       |---[]
   |---dependencies
       |---{}
```
В строке version хранится значение версии модели, это значение является исключительно описательным элементом, позволяющим разработчику ориентироваться в разных проектах при их большом количестве.
Аналогично и строки author и editor не влияют на графический интерфейс, в первой строке можно указать имя разработчика схема или программного кода, а во втором используемую программу для разработки (в примерах указано User и Wokwi для этих строк)

Далее расположены структуры кода, оказывающие влияние на графическую схему. Первый раздел - parts. В нем указаны все элементы схемы, начиная с платы разработки и заканчивая добавленными разработчиком компонентами. При этом нет разницы для симулятора как именно записать описание элементов: в одну строчку или несколько. Основное требование - каждый отдельный элемент должен находится в фигурных скобках, у него должны быть заполнены основные поля описания: Тип, Идентификатор, Положение на схеме в пикселях от верхней точки, Положение на схеме в пикселях от левого края, атрибуты элемента.

Рассмотрим пример с платой подробнее. Тип показывает что это плата разработки ESP32 `"type": "wokwi-esp32-devkit-v1"`, далее, через запятую следует идентификатор  `"id": "esp"`, расположение элемента на схеме `"top": 0, "left": 0,` и атрибуты `"attrs": {}`. Начало описания платы начинается с открывающей фигурной скобки `{` и заканчивается закрывающей `}`.

В этом же разделе, при описании диода, в атрибутах явно указывается его цвет. Несмотря на недавно появившуюся возможность выбора цвета в графическом интерфейсе ("мышкой" с использованием всплывающих кнопок), стандартным считается именно изменение атрибутов диода для выбора его цвета (аналогично и с соединениями). Это достигается добавлением строки `"attrs": { "color": "blue" }`.
Есть и другие атрибуты элементов, они не являются обязательными и описывают угол поворота элемента при отображении и возможность "спрятать" элемент. Это атрибуты `rotate` и `hide` соответственно. Первый принимает значение угла поворота, например 90, а второй скрывает элемент со схемы при значении `true`.

В примере используются 4 элемента: плата разработки, светодиод, резистор и кнопка. Поэтому и в коде также описаны 4 структуры для каждого элемента. Если опустить содержимое каждой структуры, то код для 4х элементов будет выглядить так :
```json
"parts": [{1}, {2}, {3}, {4}]
```

Следующий раздел - connections, описывает наличие проводных соединений для модулей схемы. Каждое соедиение описывается набором из трех опязательных компонентов и одного необязательного (но последний элемент может содержать несколько аргументов).
Первый компонент - исходная точка подключения. Это указатель на отдельный Pin (разъем на плате). Второй аргумент также указывает на Pin, только уже конечной точки подключения. Третий аргумент - цвет провода, если его не указать, то и провод на схеме не будет отображаться, хотя фактически будет подключен. Такие провода можно увидеть в первых двух строках раздела connections файла diagram.json. Это описание служебных подключений, без которых не будет выводиться информация с платы. Они функционируют, но на схеме их не видно. И наоборот, для некоторых соединений явно указан цвет, например "green" для провода к кнопке.
Последний(ие) атрибуты указывают на то, как именно провод должен отображаться на схеме, точнее на сколько пикселей сместить провод относительно точки подключения, а также требуется ли функция автоподключения провода к компоненту схемы.
Наглядный пример таких атрибутов представлен на анимации ниже:

![](https://docs.wokwi.com/assets/images/diagram-format-connections-447a2925ad75aad8f5940709a16ef5b4.gif)

Последняя структура dependencies описывает возможные зависимости схема от других проектов. К примеру если в одном проекте разработан модуль сбора данных, а в другом отображения данных, и их требуется объединить. Но по факту этот раздел используется достаточно редко.

В последней доступной вкладке пусто. Это происходит поскольку к текущему проекту не подключены никакие программные библиотеки.
![](./media/upd2.jpg)

Но что могут представлять собой эти библиотеки? По факту в них находится описание того, как именно нужно обращаться к разным сложным компонентам при разработке. К примеру датчик концентрации CO2 разрабатывался для подключения к интерфейсу RS-232, тогда для разработки устройства с этим датчиком в программный код необходимо включать библиотеку для интерфейса RS-232 или предоставляемую производителем датчика программную библиотеку. Без ее использования разработчику придется самостоятельно писать функции взаимодействия с датчиком, что совсем не является оптимальным в ряде случаев. Куда логичнее воспользоваться способом, предложенным производителем датчика.

С развитием симулятор все больше функций, описываемых программно, реализуются в графическом интерфейсе. Но совсем забывать про него не стоит. Например, до сих пор невозможно добавить на схему больше двух плат разработки через графический интерфейс (кнопкой "+"), а вот изменением строчки кода в diagram.json проблем не возникает.

В примере ниже показано как добавить плату разработки Arduino Nano к уже имеющейся ESP32. Это изменение затрагивает только структуру `parts`:

```json
{ "type": "wokwi-esp32-devkit-v1", "id": "esp", "top": 0, "left": 0, "attrs": {} },
    { "type": "wokwi-arduino-nano", "id": "nano", "top": -104.85, "left": -52.42, "attrs": {} },
```
